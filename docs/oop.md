# 面向对象编程

![](images/015.png)

图中的帅哥正在面向“对象”编程......

如果用一句话解释为什么要有“面向对象编程”（Object-Oriented Programming，OOP），那就是：面向对象编程可以有效地把大程序拆分成小模块，帮我们创建一个既灵活又稳定的系统：灵活体现在可以随时添加新的功能；稳定性体现在它在添加新功能时，不需要改动已有的程序模块。

随着软件规模的扩大，我们需要更高效的方式来管理复杂的系统。虽然面向过程编程和函数式编程都有各自优秀的模块化机制，但在处理复杂状态管理和模拟现实世界业务逻辑时，面向对象编程（OOP）提供了一种非常直观且强大的视角。

OOP 的核心思想是将数据（状态）和操作数据的行为（方法）绑定在一起，形成“对象”。这种方式可以有效地降低模块间的耦合度，帮我们创建一个既灵活又稳定的系统。在灵活性方面：通过继承和多态扩展新功能；在稳定性方面：封装机制保护了内部逻辑，减少了修改代码带来的副作用。

## 程序的模块划分

采用面向过程的编程思想时，会把程序看成是一组过程或功能的集合，程序通过书写顺序以及条件、循环等结构控制这些功能的执行。使用面向过程的编程思想设计程序时，最自然的方式是从上至下的设计程序。

比如，程序需要完成一项测试任务。在设计这个程序的时候，首先会设计程序的总体框架，可以把这个测试程序分为几个过程：采集数据、分析数据、显示数据、保存数据等。所以程序的主函数中就应该包含完成这个任务的子函数。接下来，再分别设计这几个子函数，也就是把这几个任务再进行细分。比如，数据采集可以由以下几个过程组成：打开硬件设备、设置硬件设备、从硬件设备读回数据、关闭硬件设备等。

这样，一个程序就很自然地被划分为不同层次的多个模块。程序规模越大，程序模块的数量就越多。由于不同的程序以及程序不同的部分多少会有些相似性，为了提高开发效率，有一些程序模块会被用在程序多个不同的部分，甚至不同的程序中。

程序规模越来越大是必然的。而大型程序的复杂度高、代码量大，需要多人合作完成，并且很可能每个程序开发人员都只能详细了解程序的一小部分。但是，在开发过程中，一个程序员如果发现自己可以利用已有的程序代码来完成所需的功能，他基本上是会直接利用已有程序代码的。此外，需求随时可能变更，每次更改需求时，不可能完全从顶层重新设计整个程序结构，必然需要迁就已有的程序模块。

因此，一个大型程序完成后，会发现它的模块之间的调用关系已经不再是最初设计得非常规范的树状结构了。模块的层次关系可能变得混乱，开发者和使用者往往无法完全了解这个模块在程序中的具体使用场景及方式。

一旦某一个模块需要改动，问题就出现了。程序模块在编写好之后，开发者可能又发现它存在一些小问题，或者对它有了新的要求需要改动它的功能。于是模块的开发者或维护者直接就按照新的要求把它改动了。但是，他们并不知道，这个模块已经被其他程序员应用在了程序的其它部分，而且使用方法并不是模块开发者或维护者所预期的那样。模块一旦被改动，程序中使用到它的其它部分也许就不能正常运行了。模块的使用者可能并不知道模块被改动过，找出程序出错的原因也需要花费不少精力。

代码和模块的重用，在大型程序中是不可避免的。大型程序开发和维护的困难，很大一部分就是这种模块使用的混乱造成的。为了解决这个问题，必须找到一种更好的模块设计和实现方式。程序中模块的接口应当非常清晰，模块的使用者应该可以轻易地了解到一个模块有哪些数据，哪些方法。对模块的使用应当进行限制，比如模块中某些方法可以被其它程序使用；而模块中将来可能会改变、或者可能会引起问题的方法则不能公开，应该禁止被其它程序使用。模块还应该能够方便地升级、优化，以及添加新的功能等等。诸如此类的一些问题，都可以使用面向对象的程序设计方法来解决。

## 类和对象

现实世界是由各种各样的实体所组成的。比如，屋子里有一张桌子、一把椅子、一台电脑等实体。有些实体，它们之间有很多共同点，可以被划分为同一**类**。比如说，“人”是一个类，“阮奇桢”这个人则是人类中的一个实体。人类中的实体都有一些共同的特点，比如用两条腿走路、能说话、会思考等。

计算机软件都是为了解决现实世界中的某个问题或是对现实世界某个方面的模拟。在程序设计中，同样存在类似的情况。比如，为公司编写一个管理软件，公司里有多名员工：张三、李四、王二麻子等。这些员工都有一些共同的、需要程序处理的特点，比如姓名、性别、年龄等，虽然这些特性的值可能不同。

**对象**是属于某个类的一个实体，有时会直接被称为**实例**。比如，上例中每一个具体的员工（如张三），是员工类的一个对象。

**属性**也经常被叫做**数据**或者**变量**，是用来描述对象静态状态的。比如员工类的实例，也就是每个员工，需要有姓名、性别、年龄等属性。

**方法**也经常被叫做**函数**，用来描述对象的动作。比如员工类的实例可能会有加班，领取工资等方法。

## 面向对象的程序设计

面向对象的程序设计方法，是指在开发程序时以对象作为程序的基本模块，而不是如同面向过程的程序设计方法那样，以程序的功能或过程来划分模块。以对象作为程序的基本模块，可以提高程序的重用性、灵活性和扩展性。

面向对象的程序设计有三大特征：封装性、继承性和多态性。

### 封装（数据抽象）

封装（Encapsulation）是指，把高度相关的一组数据和方法组织在一起，形成一个相对独立的模块（类）。

外部程序只能通过严格定义的公开接口（Public Methods）来访问这个模块的数据；而对于不需要外部访问的内部细节（Private Data），则将其隐藏和保护起来，就像一个黑匣子。这样，对象内部的修改不会影响到外部的使用者，大大提高了系统的可维护性。

比如，需要设计一个用来模拟几个小动物日常生活的程序。在设计程序时，可以把所有小动物的行为和特性抽象归为一个“动物”类。这个类包括了一些公开的属性，如年龄、产地、名字等等；还可以包含一些公开方法，即动物的行为，比如进食、移动、发声等。这个动物类中还有一些内部的属性和方法，它们只能提供类内部使用，而不能被类之外的其它程序调用。比如，让动物走几步，可以通过调用动物类的移动方法，这个方法在内部其实还调用了类的一个私有属性：“腿的数目”，而这个属性是不能够被类之外的程序直接修改或读取的。

### 继承

继承（Inheritance）允许我们在一个已有类（父类）的基础上，定义新的类（子类）。子类自动获得父类的属性和方法，同时可以定义自己特有的特性。这不仅避免了代码重复，还建立了清晰的层级关系，让我们能够对现实世界的分类进行建模。

比如，程序中包含几只小狗和几只小鸡，它们都是动物类的实例。但是，小狗们还有它们共有的一些特点。为了使程序代码更好地被重用，这些共同点也应被抽象出来，形成一个子类，“狗”类。

动物类的所有属性和方法，狗类也都具有。所以在定义狗类的时候，先声明它是动物类的一个子类，这样，狗类就立刻具备了所有动物类公开了的属性和方法。再加上狗的一些特殊属性和方法就可以了，比如狗“看家”，鸡“下蛋”等。

子类常常也被叫做**派生类**；父类也可以被称为**基类**、**超类**。父类、父类的父类或更往上的被统称为**祖先类**；相对应，子类、子类的子类或更往下的被统称为**子孙类**或后代类。

### 多态（动态绑定）

多态（Polymorphism）最早也是个遗传学概念，指源自同一祖先的不同生物会表现出多种不同形态。

在面向对象的程序中，多态是指同一个行为（方法），在不同的对象上具有不同的表现形式。在编程中，多态允许我们要使用统一的接口来操作不同类型的对象。

虽然子类具有很多继承自父类的相同的方法，但它们的实现可以是不同的。在调用这些方法时，可以使用父类的名称来调用它们。这样，程序虽然调用了相同的方法，但是因为它们所属的子类不同，其表现行为也会不同。使用多态，可以让我们在应用程序中，在一定程度上忽略相似模块的区别，而以统一的方式调用它们。

比如，几个子类同样都具有一个继承自父类“动物”的方法“发声”。而不同的子类，狗和鸡的“发声”的实现代码是不相同的：狗汪汪，鸡打鸣。这样，在应用程序中需要让一组动物逐个发声时，可以把所有动物都当作是动物类的一个实例，使用相同的代码调用每个实例对应的动物类的“发声”方法。而程序运行到这里，会自动判断要处理的实例是属于“狗”子类还是属于“鸡”子类，然后分别调用狗或鸡类中“发声”方法，或发出汪汪声，或发出唧唧声。

关键点在于： 编写“发声”函数的程序员不需要关心传入的到底是狗还是鸡，只需要调用统一的“发声”方法即可。程序会在运行时自动判断对象的实际类型，并执行相应的代码（这被称为动态绑定）。这极大地提高了程序的扩展性——如果你后来增加了一个“鸭子”类，不需要修改“发声”函数，鸭子也能正常发声。

